<script src="../simpletest.js"></script>
<script>

// Prototype implementation?

// Function signature:
  // find(array, callback(element[, index[, array]])[, thisArg])

// Callback parameters:
  // element 
  // index
  // array

// Return value:
  // Returns the value of the first element.

// Description:
// The find method executes the callback function once for each index of the array 
// until the callback returns a truthy value. 

// callback is invoked for every index of the array, not just those with assigned values.
// find should return a new array, not the original array. 

// Case A: A truthy value is found.
  // find immediately returns the value of that element.
// Case B: A truthy value is not found.
  // find returns undefined.

// Case C: thisArg parameter is provided to find.
  // thisArg parameter will be used as the this value inside each invocation of the callback.
// Case D: thisArg parameter is not provided to find.
  // undefined is used.

// Cases E/F are not needed because we handle them in the three tests below.
  // Case E: Callback is not provided.
    // find won't mutate the array on which its called.
  // Case F: Callback is provided.
    // find will first set its processed elements before the first invocation of callback.

  // callback will not visit any elements added to the array after the call to find begins.
  // If an existing, yet-unvisited element of the array is changed by callback, its value 
    // passed to the callback will be the value at the time find visits that element's index.
  // Elements that are deleted are still visited.

// Test descriptions:
// #1: 'It should run array.length times.'
// #2: 'It should pass in ith element as the first argument.'
// #3: 'It should pass in index as the second argument.'
// #4: 'It should pass in the original array as the third argument.'
// #5: 'It should accept an optional this argument.'
// #6: 'If no optional this argument, this should be be undefined.'
// #7: 'If truthy value, it should immediately return the value of that element.'
// #8: 'If no truthy value, it should return undefined.'
// #9: 'It should also run on empty holes in the array.'
// #10: 'It should not allow callback to visit any elements added to array after call to find begins.'
// #11: 'It should pass in the current value of an element to the callback.'
// #12: 'It should still call callback on deleted elements.'
// #13: 'It should return a new array, not the original array.'

// Code:
function find(originalArray, callback, optionalThis) {
  var findCallback = callback;
  var arrayLength = originalArray.length;

  if (optionalThis) {
    findCallback = callback.bind(optionalThis);
  }

  for (var i = 0; i < arrayLength; i++) {
    if ((findCallback(originalArray[i], i, originalArray)) === true) {
      return originalArray[i];
    }
  }
}

tests({
  'It should run array.length times.': function() {
    var numberOfTimesCallbackHasRun = 0;
    find([1, 2, 3], function() {
      numberOfTimesCallbackHasRun++;
    })
    eq(numberOfTimesCallbackHasRun, 3);
  },
  'It should pass in ith element as the first argument.': function() {
    find([1], function(element) {
      eq(element, 1);
    }); 
  },
  'It should pass in index as the second argument.': function() {
    find([1], function(element, index) {
      eq(index, 0);
    });
  },
  'It should pass in the original array as the third argument.': function() {
    var testArray = [1, 2, 3];
    find(testArray, function(element, index, originalArray) {
      eq(originalArray, testArray);
    });
  },
  'It should accept an optional this argument.': function() {
    find([1], function() {
      eq(this.description, 'I should be accessible inside of the callback');
    }, {description: 'I should be accessible inside of the callback'});
  },
  'If no optional this argument, this should be undefined.': function() {
    find([1], function(element, index, array) {
      eq(this.description, undefined);
    });
  },
  'If truthy value, it should immediately return the value of that element.': function() {
    var result = find([1, 2, 3], function(element) {
      return element > 2;
    });
    eq(result, 3);
  },
  'If no truthy value, it should return undefined.': function() {
    var result = find([1, 2, 3], function(element) {
      return element > 3;
    });
    eq(result, undefined);
  },
  'It should also run on empty holes in the array.': function() {
    var numberOfTimesCallbackHasRun = 0;
    find([, 1, , 2, , 3], function() {
      numberOfTimesCallbackHasRun++;
    });
    eq(numberOfTimesCallbackHasRun, 6);
  },
  'It should not allow callback to visit any elements added to array after call to find begins.': function() {
    var numberOfTimesCallbackHasRun = 0;
    find([1, 2, 3], function(element, index, array) {
      array.push(1);
      numberOfTimesCallbackHasRun++;
    });
    eq(numberOfTimesCallbackHasRun, 3);
  },
  'It should pass in the current value of an element to the callback.': function() {
    var result = find ([1, 2], function(element, index, array) {
      array[1] = 3;
      return element > 2;
    });
    eq(result, 3);
  },
  'It should still call callback on deleted elements.': function() {
    var numberOfTimesCallbackHasRun = 0;
    find([1, 2], function(element, index, array) {
      numberOfTimesCallbackHasRun++;
      if (index === 0) {
        delete array[1];
      }
    });
    eq(numberOfTimesCallbackHasRun, 2);
  },
  'It should return a new array, not the original array.': function() {
    var oldArray = [];
    var newArray = find(oldArray, function() {});
    eq(newArray !== oldArray, true); 
  }
});
</script>